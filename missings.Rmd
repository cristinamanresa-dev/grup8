---
title: "preprocessing missings"
author: "Laia ribes"
date: "2025-10-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Llegim les dades

```{r}
train <- read.csv("train_AED.csv")
test <- read.csv("test_AED.csv")
```

tot el apartat del little test ens el podem estalviar ja que esl NA's en les nostres dades estan distribuits completament aleatoriament i per tant no es pot arribar a calcular la matriu de covariancies

# 4.3 patrons descriptius dels na 

```{r}
library(visdat)
library(ggplot2)
library(naniar)

vis_dat(train);
vis_miss(train)
```

amb aixo podem observar que no hi ha cap linia on siguin tot missings, per tant no fa falta eliminar cap fila 

(el codi del ggplot no ens funciona i per tant no el durem a terme)

## visualitzacio dels na per variables 

```{r}
gg_miss_var(train) + labs(y = "Look at all the missing ones")
```
veiem que totes les variables contenen el mateix nombre de missings

## deteccio dels nas en la base de dades 

```{r}
train_shadow <- bind_shadow(train)
```


aixo no ens dona cap mena de conclusio ni informacio ja que hi veiem molts na 
```{r}
train %>%
  bind_shadow() %>%
  group_by(speechiness) %>%
  summarise_at(.vars = "loudness",
               .funs = c("mean", "sd", "var", "min", "max"),
               na.rm = TRUE)
```

```{r}
str(train)
```

si ho fem amb alguna variable numerica no ens donara be, s'ha de fer amb una variable factor
```{r}
ggplot(train_shadow,
       aes(x = song_popularity,
           colour = speechiness_NA)) + 
  geom_density()
```

La distribució de popularitat entre cançons amb i sense valor d’‘instrumentalness’ és pràcticament idèntica. Per tant, els valors perduts no semblen associats a cançons amb comportaments diferents en termes de popularitat, cosa que apunta a una absència de biaix rellevant (possibles MCAR o MAR febles)

## extreu estadistiques amb nas de las base de dades

(aquest apartat com que no se ben be quines conclusions en podem treure no lhe fet)


# imputació per MICE

```{r}
train <- read.csv("train_AED.csv")
```

Eliminamos las variables categoricas

```{r}
# Manté només les variables numèriques
train_numeric <- train[, sapply(train, is.numeric)]
summary(train_numeric)

quiCat <- which(lapply(train, class) %in% c("character", "factor"))
(categories <- names(train)[quiCat])
train2 <- subset(train, select = -c(get(categories)))
summary(train2)
```

visualitzem els patrons dels nas 
```{r}
par(mfrow = c(1, 1))
mice::md.pattern(train_numeric, rotate.names = TRUE)
```


a continuacaio realitzezm imputacio dels valors faltants de manera multivariada

```{r}
imputed_Data <- mice::mice(train_numeric, m=5, maxit = 50, method = 'pmm', seed = 500)
```

```{r}
summary(imputed_Data)
```

inspeccionamos la calidad de las imputaciones 
```{r}
mice::stripplot(imputed_Data, loudness, pch = 19, xlab = "Imputation number")
```

veiem que els valors imputats no son massa diferents als valors originals, ho podem anar comprovant variable per varibale i aixi saber si ha sigut un bon metode per imputar

```{r}
completeData <- mice::complete(imputed_Data, action = "long")
completeData$time_signature_cat <- NULL

summary(completeData)
```

donem per bona la imputació per mice. ara haurem de passar a la imputació de les variables categoriques 


# KNN 

per poder començar haurem de convertir la variable time_signature_cat a categorica, ja que no esta ben cpnvertida en el data

```{r}
#  Carregar llibreria
library(VIM)

#  Convertir automàticament totes les columnes de tipus "character" a "factor"
train[] <- lapply(train, function(x) {
  if (is.character(x)) as.factor(x) else x
})

#  Assegurar que time_signature_cat és factor (per si ve com integer)
if (!is.factor(train$time_signature_cat)) {
  train$time_signature_cat <- as.factor(train$time_signature_cat)
}

#  Comprovació del tipus final de variables
str(train)

train_cat <- train[, sapply(train, is.factor)]
summary(train_cat)

# Fusionar datasets per columnes
data_final <- cbind(completeData, train_cat)

```


```{r}
#  Aplicar imputació KNN a tot el dataset
imputed_data <- kNN(data_final, k = 5, imp_var = FALSE)

#  Comprovar que no queden NA
colSums(is.na(imputed_data))
```

```{r}
str(imputed_data)
```

```{r}

# Solució robusta per arreglar factors després de kNN (VIM)
for (col in names(imputed_data)) {
  if (is.factor(imputed_data[[col]])) {
    imputed_data[[col]] <- as.character(imputed_data[[col]])   # Convertir segur
    imputed_data[[col]][imputed_data[[col]] == ""] <- NA       # Eliminar buits
    imputed_data[[col]] <- as.factor(imputed_data[[col]])      # Tornar a factor
  }
}


```

