---
title: "preprocessing missings"
author: "Laia ribes"
date: "2025-10-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Llegim les dades

```{r}
train <- read.csv("train_AED.csv")
test <- read.csv("test_AED.csv")
```

tot el apartat del little test ens el podem estalviar ja que esl NA's en les nostres dades estan distribuits completament aleatoriament i per tant no es pot arribar a calcular la matriu de covariancies

# 4.3 patrons descriptius dels na 

```{r}
library(visdat)
library(ggplot2)
library(naniar)

vis_dat(train);
vis_miss(train)
```

amb aixo podem observar que no hi ha cap linia on siguin tot missings, per tant no fa falta eliminar cap fila 

(el codi del ggplot no ens funciona i per tant no el durem a terme)

## visualitzacio dels na per variables 

```{r}
gg_miss_var(train) + labs(y = "Look at all the missing ones")
```
veiem que totes les variables contenen el mateix nombre de missings

## deteccio dels nas en la base de dades 

```{r}
train_shadow <- bind_shadow(train)
```


aixo no ens dona cap mena de conclusio ni informacio ja que hi veiem molts na 
```{r}
train %>%
  bind_shadow() %>%
  group_by(speechiness) %>%
  summarise_at(.vars = "loudness",
               .funs = c("mean", "sd", "var", "min", "max"),
               na.rm = TRUE)
```

```{r}
str(train)
```

si ho fem amb alguna variable numerica no ens donara be, s'ha de fer amb una variable factor
```{r}
ggplot(train_shadow,
       aes(x = song_popularity,
           colour = speechiness_NA)) + 
  geom_density()
```

La distribució de popularitat entre cançons amb i sense valor d’‘instrumentalness’ és pràcticament idèntica. Per tant, els valors perduts no semblen associats a cançons amb comportaments diferents en termes de popularitat, cosa que apunta a una absència de biaix rellevant (possibles MCAR o MAR febles)

## extreu estadistiques amb nas de las base de dades

(aquest apartat com que no se ben be quines conclusions en podem treure no lhe fet)

# imputacio basica

```{r}
#media
train[, "imputed_speechiness"] <- with(train, Hmisc::impute(speechiness, mean))
#mediana
pre_median <- preProcess(train, method = "medianImpute")
imputed_median <- predict(pre_median, train)
diagnose(imputed_median)
#valor aleatori
train[, "imputed_speechiness2"] <- with(train, Hmisc::impute(speechiness, 'random'))
```

veiem que per la mediana ha creat un nou data set amb tots els vlaors de les variables numeiques imputats per la seva mediana 

## representa la distribució a variables reals i d'imputació a treves del grafic de densitat

```{r}
library(dplyr)
library(tidyr)

df_long <- train %>%
  select(speechiness, imputed_speechiness, imputed_speechiness2) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "Valor")


ggplot(df_long, aes(x = Valor, fill = Variable)) +
  geom_density(alpha = 0.3) +  # Transparencia para mejor visualización
  labs(title = "Densidad de las tres variables",
       x = "Valor",
       y = "Densidad") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))
```
NO FUNCIONA AQUEST TROS DE CODI


Una altra opció és usant el paquet argImpute(nose quines variables ficar)

nomes es pot utilitzar en variables numeriques int o factors, sino no funciona i ens dona error, i sempre s'haurà d'incloure la variable song_popularitty per tal de que tingui una referencia a l'hora d'imputar 
```{r}
(impute_arg <- Hmisc::aregImpute(~ song_popularity + speechiness + loudness + danceability + song_duration_ms + energy + audio_valence 
                           , data = train, n.impute = 5))
```

d'aqui en podem extreure varies conclusions rellevants, si el valor del r^2 es >0,6 vol dir que hi ha una bona prediccio i per tant es poden imputar relativament be, si esta en 0,2-0,3 tenen una predicció moderada i si es < a 0,1 es una mala predicció i llavrps les imputacions seran menys fiables i no es recomanat dur a terme una imputacio multiple 

passem a un nou metode d'imputació 

# multiple iterative regression imputation

no ens funcionava pq tenim dues variables completameent iguals, com ara eren time_signature ii time_signature_cat, creem una nova base de dades i n'eliminem una per tal de poder dur a terme aquesta part 

tambe estaria be provar si 
```{r}
train <- read.csv("train_AED.csv")

mitrain <- train
mitrain$time_signature_cat <- NULL
mi_data <- mi::mi(mitrain, seed = 335) #segueix sense funcionar 

summary(mi_data)
plot(mi_data)
par(ask = FALSE)

mi_data@data
```

# media con una variable target

```{r}
#definim la varibale trget
target <- "song_popularity"

#definim la base de datos amb nas
data <- subset(train, select = -c(get(target)))
data <- missForest::prodNA(data, noNA = 0.1)
data$song_popularity <- train[, target]

#definim variables a imputar
varImp <- colnames(data)[which(!colnames(data) %in% target)]

#calcular las medias por grupo
means <- aggregate(data[, varImp], list(data[, target]), mean, na.rm = TRUE)

#impuar valores faltantes 
for (c in varImp) {
  for (g in means[, "Group.1"]) {
    cond <- data[, target] == g  # Condición booleana en vez de which()
    na_index <- is.na(data[, c]) & cond  # Seleccionar NA dentro del grupo
    
    # Asignar valores imputados
    data[na_index, c] <- means[means[, "Group.1"] == g, c]
  }
}
summary(data)


```

visualitzarem la dieferencia entre les imputacions 

```{r}
train[, "Tipo"] <- "original"
data[, "Tipo"] <- "imputed"
```

unim en un mateix data frame

```{r}
data_long <- bind_rows(train, data)
cols_numeric <- names(data_long)[sapply(data_long, is.numeric) & names(data_long) != "Tipo"]

# Convert a large data
data_long <- data_long %>%
  pivot_longer(cols = all_of(cols_numeric), names_to = "Variable", values_to = "Valor")

#CREEM EL GRAFIC
ggplot(data_long, aes(x = Valor, fill = Tipo)) +
  geom_density(alpha = 0.3) +  # Transparencia para comparación
  facet_wrap(~Variable, scales = "free") +  # Un gráfico por variable
  labs(title = "Comparación de Distribuciones: Original vs Imputado",
       x = "Valor",
       y = "Densidad") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red"))
```


# imputació per MICE

```{r}
train <- read.csv("train_AED.csv")
```

Eliminamos las variables categoricas

```{r}
# Manté només les variables numèriques
train_numeric <- train[, sapply(train, is.numeric)]
summary(train_numeric)

quiCat <- which(lapply(train, class) %in% c("character", "factor"))
(categories <- names(train)[quiCat])
train2 <- subset(train, select = -c(get(categories)))
summary(train2)
```

visualitzem els patrons dels nas 
```{r}
par(mfrow = c(1, 1))
mice::md.pattern(train_numeric, rotate.names = TRUE)
```


a continuacaio realitzezm imputacio dels valors faltants de manera multivariada

```{r}
imputed_Data <- mice::mice(train_numeric, m=5, maxit = 50, method = 'pmm', seed = 500)
```

```{r}
summary(imputed_Data)
```

inspeccionamos la calidad de las imputaciones 
```{r}
mice::stripplot(imputed_Data, loudness, pch = 19, xlab = "Imputation number")
```

veiem que els valors imputats no son massa diferents als valors originals, ho podem anar comprovant variable per varibale i aixi saber si ha sigut un bon metode per imputar

```{r}
completeData <- mice::complete(imputed_Data, action = "long")
summary(completeData)
```

donem per bona la imputació per mice. ara haurem de passar a la imputació de les variables categoriques 

```{r}
str(train)
```

# KNN 

per poder començar haurem de convertir la variable time_signature_cat a categorica, ja que no esta ben cpnvertida enn el data

```{r}
train <- read.csv("train_AED.csv")
```

```{r}
#  Carregar llibreria
library(VIM)

#  Convertir automàticament totes les columnes de tipus "character" a "factor"
train[] <- lapply(train, function(x) {
  if (is.character(x)) as.factor(x) else x
})

#  Assegurar que time_signature_cat és factor (per si ve com integer)
if (!is.factor(train$time_signature_cat)) {
  train$time_signature_cat <- as.factor(train$time_signature_cat)
}

#  Comprovació del tipus final de variables
str(train)

#  Aplicar imputació KNN a tot el dataset
imputed_data <- kNN(train, k = 5, imp_var = FALSE)

#  Comprovar que no queden NA
colSums(is.na(imputed_data))

```

```{r}
str(imputed_data)
```

```{r}
# Solució: Convertir tots els factors a factors nets i coherents
imputed_data[] <- lapply(imputed_data, function(x) {
  if (is.factor(x)) {
    x <- droplevels(x)    # Elimina nivells buits/inexistents
    x <- as.factor(as.character(x))  # Reinicialitza el factor correctament
  }
  return(x)
})


```

